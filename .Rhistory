hessian <- diag(gradient^2)
return(list(value = value, gradient = gradient, hessian = hessian))
}
test <- obj(c(yini, pars))
test
library(trust)
myfit <- trust(obj, c(yini, pars), rinit=1, rmax=10)
myfit$converged
myfit$value
myfit$argument
prediction <- odeC(y = c(myfit$argument[1:3], yini_s, yini_chi, yini_grad),
times = times, func = func, parms = myfit$argument[4:5], forcings = forc,
method = "lsodes")
par(mfcol=c(1,2))
t <- prediction[,1]
M1 <- prediction[,2:4]
M2 <- prediction[,names(grad)]
tD <- oxygenData[,1]
M1D <- oxygenData[,2:4]
matplot(t, M1, type="l", lty=1, col=1:3, xlab="time", ylab="value", main="states")
matplot(tD, M1D, type="l", lty=2, col=1:3, add=TRUE)
legend("topright", legend = names(f), lty=1, col=1:3)
matplot(t, M2, type="l", lty=1, col=1:5, xlab="time", ylab="value", main="gradient")
legend("bottomleft", legend = names(grad), lty=1, col=1:5)
myfit
source('~/cOde/inst/examples/example3.R')
obj(c(yini, pars))
myfit <- optim(par = c(yini, pars),
fn = function(p) obj(p)$value,
gr = function(p) obj(p)$gradient,
method="L-BFGS-B",
lower = 0,
upper = 5)
myfit
myfit <- trust(obj, c(yini, pars), rinit=1, rmax=10)
myfit
out <- odeC(y = c(yini, yini_s, yini_chi, yini_grad),
times = times, func = func, parms = pars, forcings = forc,
method = "lsodes")
# Plot solution
par(mfcol=c(1,2))
t <- out[,1]
M1 <- out[,2:4]
M2 <- out[,names(grad)]
tD <- oxygenData[,1]
M1D <- oxygenData[,2:4]
matplot(t, M1, type="l", lty=1, col=1:3, xlab="time", ylab="value", main="states")
matplot(tD, M1D, type="l", lty=2, col=1:3, add=TRUE)
legend("topright", legend = names(f), lty=1, col=1:3)
matplot(t, M2, type="l", lty=1, col=1:5, xlab="time", ylab="value", main="gradient")
legend("topleft", legend = names(grad), lty=1, col=1:5)
out <- odeC(y = c(yini, yini_s, yini_chi, yini_grad),
times = times, func = func, parms = pars, forcings = forc,
method = "lsoda")
# Plot solution
par(mfcol=c(1,2))
t <- out[,1]
M1 <- out[,2:4]
M2 <- out[,names(grad)]
tD <- oxygenData[,1]
M1D <- oxygenData[,2:4]
matplot(t, M1, type="l", lty=1, col=1:3, xlab="time", ylab="value", main="states")
matplot(tD, M1D, type="l", lty=2, col=1:3, add=TRUE)
legend("topright", legend = names(f), lty=1, col=1:3)
matplot(t, M2, type="l", lty=1, col=1:5, xlab="time", ylab="value", main="gradient")
legend("topleft", legend = names(grad), lty=1, col=1:5)
# Solve ODE
out <- odeC(y = c(yini, yini_s, yini_chi, yini_grad),
times = times, func = func, parms = pars, forcings = forc,
method = "lsodes")
# Plot solution
par(mfcol=c(1,2))
t <- out[,1]
M1 <- out[,2:4]
M2 <- out[,names(grad)]
tD <- oxygenData[,1]
M1D <- oxygenData[,2:4]
matplot(t, M1, type="l", lty=1, col=1:3, xlab="time", ylab="value", main="states")
matplot(tD, M1D, type="l", lty=2, col=1:3, add=TRUE)
legend("topright", legend = names(f), lty=1, col=1:3)
matplot(t, M2, type="l", lty=1, col=1:5, xlab="time", ylab="value", main="gradient")
legend("topleft", legend = names(grad), lty=1, col=1:5)
out
myfit <- trust(obj, c(yini, pars), rini=1, rmax=10, mtol=1e-16, ftol=0)
myfit <- trust(obj, c(yini, pars), rini=1, rmax=10, mterm=1e-16, fterm=0)
myfit
numDeriv::grad(function(p) obj(p)$value, c(yini, pars))
obj(c(yini, pars))$gradient
grad
chi
class(out) <- "deSolve"
plot(out)
yini_s
yini_chi
yini_grad
source('~/cOde/inst/examples/example3.R')
obj(c(yini, pars))$gradient
numDeriv::grad(function(p) obj(p)$value, c(yini, pars))
obj <- function(p) {
out <- odeC(y = c(p[names(f)], yini_s, yini_chi, yini_grad),
times = times, func = func, parms = p[names(pars)], forcings = forc, method="lsodes"
atol=1e-8, rtol=1e-8)
value <- as.vector(tail(out, 1)[,"chi"])
gradient <- as.vector(tail(out, 1)[,names(grad)])
hessian <- gradient%*%t(gradient)
return(list(value = value, gradient = gradient, hessian = hessian))
}
# Define objective function
obj <- function(p) {
out <- odeC(y = c(p[names(f)], yini_s, yini_chi, yini_grad),
times = times, func = func, parms = p[names(pars)], forcings = forc, method="lsodes",
atol=1e-8, rtol=1e-8)
value <- as.vector(tail(out, 1)[,"chi"])
gradient <- as.vector(tail(out, 1)[,names(grad)])
hessian <- gradient%*%t(gradient)
return(list(value = value, gradient = gradient, hessian = hessian))
}
obj(c(yini, pars))$gradient
numDeriv::grad(function(p) obj(p)$value, c(yini, pars))
obj <- function(p) {
out <- odeC(y = c(p[names(f)], yini_s, yini_chi, yini_grad),
times = times, func = func, parms = p[names(pars)], forcings = forc, method="lsodes",
atol=1e-8, rtol=1e-8)
value <- as.vector(tail(out, 1)[,"chi"])
gradient <- as.vector(tail(out, 1)[,names(p)[names(grad)]])
hessian <- gradient%*%t(gradient)
return(list(value = value, gradient = gradient, hessian = hessian))
}
numDeriv::grad(function(p) obj(p)$value, c(yini, pars))
names(grad)
obj <- function(p) {
out <- odeC(y = c(p[names(f)], yini_s, yini_chi, yini_grad),
times = times, func = func, parms = p[names(pars)], forcings = forc, method="lsodes",
atol=1e-8, rtol=1e-8)
value <- as.vector(tail(out, 1)[,"chi"])
gradient <- as.vector(tail(out, 1)[,paste("chi", names(p), sep=".")]
hessian <- gradient%*%t(gradient)
return(list(value = value, gradient = gradient, hessian = hessian))
}
obj <- function(p) {
out <- odeC(y = c(p[names(f)], yini_s, yini_chi, yini_grad),
times = times, func = func, parms = p[names(pars)], forcings = forc, method="lsodes",
atol=1e-8, rtol=1e-8)
value <- as.vector(tail(out, 1)[,"chi"])
gradient <- as.vector(tail(out, 1)[,paste("chi", names(p), sep=".")])
hessian <- gradient%*%t(gradient)
return(list(value = value, gradient = gradient, hessian = hessian))
}
numDeriv::grad(function(p) obj(p)$value, c(yini, pars))
obj(c(yini, pars))$gradient
myfit <- trust(obj, c(yini, pars), rini=1, rmax=10, mterm=1e-16, fterm=0)
myfit <- trust(obj, c(yini, pars), rini=1, rmax=10)
obj <- function(p) {
out <- odeC(y = c(p[names(f)], yini_s, yini_chi, yini_grad),
times = times, func = func, parms = p[names(pars)], forcings = forc, method="lsodes")
value <- as.vector(tail(out, 1)[,"chi"])
gradient <- as.vector(tail(out, 1)[,paste("chi", names(p), sep=".")])
hessian <- gradient%*%t(gradient)
return(list(value = value, gradient = gradient, hessian = hessian))
}
myfit <- trust(obj, c(yini, pars), rini=1, rmax=10)
obj(c(yini, pars))
source('~/cOde/inst/examples/example3.R')
myfit <- trust(obj, c(yini, pars), rini=.1, rmax=10)
myfit <- trust(obj, c(yini, pars), rini=.1, rmax=1)
yini
pars
obj(c(yini, pars))
myfit <- trust(obj, c(yini, pars), rinit=.1, rmax=1)
obj <- function(p) {
names(p) <- c(names(f), names(pars))
out <- odeC(y = c(p[names(f)], yini_s, yini_chi, yini_grad),
times = times, func = func, parms = p[names(pars)], forcings = forc, method="lsodes")
value <- as.vector(tail(out, 1)[,"chi"])
gradient <- as.vector(tail(out, 1)[,paste("chi", names(p), sep=".")])
hessian <- gradient%*%t(gradient)
return(list(value = value, gradient = gradient, hessian = hessian))
}
myfit <- trust(obj, c(yini, pars), rinit=.1, rmax=1)
obj <- function(p) {
names(p) <- c(names(f), names(pars))
print(p)
out <- odeC(y = c(p[names(f)], yini_s, yini_chi, yini_grad),
times = times, func = func, parms = p[names(pars)], forcings = forc, method="lsodes")
value <- as.vector(tail(out, 1)[,"chi"])
gradient <- as.vector(tail(out, 1)[,paste("chi", names(p), sep=".")])
hessian <- gradient%*%t(gradient)
return(list(value = value, gradient = gradient, hessian = hessian))
}
myfit <- trust(obj, c(yini, pars), rinit=.1, rmax=1)
obj <- function(p) {
names(p) <- c(names(f), names(pars))
print(p)
out <- odeC(y = c(p[names(f)], yini_s, yini_chi, yini_grad),
times = times, func = func, parms = p[names(pars)], forcings = forc, method="lsodes")
value <- as.vector(tail(out, 1)[,"chi"])
gradient <- as.vector(tail(out, 1)[,paste("chi", names(p), sep=".")])
hessian <- gradient%*%t(gradient)
return(list(value = value, gradient = gradient, hessian = hessian))
}
myfit <- trust(obj, c(yini, pars), rinit=.01, rmax=1)
obj <- function(p) {
names(p) <- c(names(f), names(pars))
print(p)
out <- odeC(y = c(p[names(f)], yini_s, yini_chi, yini_grad),
times = times, func = func, parms = p[names(pars)], forcings = forc, method="lsodes")
value <- as.vector(tail(out, 1)[,"chi"])
gradient <- as.vector(tail(out, 1)[,paste("chi", names(p), sep=".")])
hessian <- gradient%*%t(gradient)
return(list(value = value, gradient = gradient, hessian = hessian))
}
myfit <- trust(obj, c(yini, pars), rinit=.001, rmax=1)
myfit
prediction <- odeC(y = c(myfit$argument[1:3], yini_s, yini_chi, yini_grad),
times = times, func = func, parms = myfit$argument[4:5], forcings = forc,
method = "lsodes")
par(mfcol=c(1,2))
t <- prediction[,1]
M1 <- prediction[,2:4]
M2 <- prediction[,names(grad)]
tD <- oxygenData[,1]
M1D <- oxygenData[,2:4]
matplot(t, M1, type="l", lty=1, col=1:3, xlab="time", ylab="value", main="states")
matplot(tD, M1D, type="l", lty=2, col=1:3, add=TRUE)
legend("topright", legend = names(f), lty=1, col=1:3)
matplot(t, M2, type="l", lty=1, col=1:5, xlab="time", ylab="value", main="gradient")
legend("bottomleft", legend = names(grad), lty=1, col=1:5)
myfit <- optim(par = c(yini, pars),
fn = function(p) obj(p)$value,
gr = function(p) obj(p)$gradient,
method = "BFGS")
myfit <- optim(par = c(yini, pars),
fn = function(p) obj(p)$value,
gr = function(p) obj(p)$gradient,
method = "L-BFGS-B",
lower=0,
upper=5)
myfit
prediction <- odeC(y = c(myfit$par[1:3], yini_s, yini_chi, yini_grad),
times = times, func = func, parms = myfit$par[4:5], forcings = forc,
method = "lsodes")
par(mfcol=c(1,2))
t <- prediction[,1]
M1 <- prediction[,2:4]
M2 <- prediction[,names(grad)]
tD <- oxygenData[,1]
M1D <- oxygenData[,2:4]
matplot(t, M1, type="l", lty=1, col=1:3, xlab="time", ylab="value", main="states")
matplot(tD, M1D, type="l", lty=2, col=1:3, add=TRUE)
legend("topright", legend = names(f), lty=1, col=1:3)
matplot(t, M2, type="l", lty=1, col=1:5, xlab="time", ylab="value", main="gradient")
legend("bottomleft", legend = names(grad), lty=1, col=1:5)
source('~/cOde/inst/examples/example3.R')
source('~/cOde/inst/examples/example3.R')
matplot(t, M1, type="l", lty=1, col=1:3, xlab="time", ylab="value", main="states")
matplot(tD, M1D, type="b", lty=2, col=1:3, add=TRUE)
legend("topright", legend = names(f), lty=1, col=1:3)
matplot(t, M2, type="l", lty=1, col=1:5, xlab="time", ylab="value", main="gradient")
legend("topleft", legend = names(grad), lty=1, col=1:5)
matplot(t, M1, type="l", lty=1, col=1:3, xlab="time", ylab="value", main="states")
matplot(tD, M1D, type="b", lty=2, col=1:3, pch=1, add=TRUE)
legend("topright", legend = names(f), lty=1, col=1:3)
matplot(t, M2, type="l", lty=1, col=1:5, xlab="time", ylab="value", main="gradient")
matplot(t, M1, type="l", lty=1, col=1:3, xlab="time", ylab="value", main="states")
matplot(tD, M1D, type="b", lty=2, col=1:3, pch=19, add=TRUE)
legend("topright", legend = names(f), lty=1, col=1:3)
matplot(t, M2, type="l", lty=1, col=1:5, xlab="time", ylab="value", main="gradient")
legend("topleft", legend = names(grad), lty=1, col=1:5)
source('~/cOde/inst/examples/example3.R')
matplot(t, M1, type="l", lty=1, col=1:3, xlab="time", ylab="value", main="states")
matplot(tD, M1D, type="b", lty=2, col=1:3, pch=2, add=TRUE)
legend("topright", legend = names(f), lty=1, col=1:3)
matplot(t, M2, type="l", lty=1, col=1:5, xlab="time", ylab="value", main="gradient")
legend("topleft", legend = names(grad), lty=1, col=1:5)
?pch
matplot(t, M1, type="l", lty=1, col=1:3, xlab="time", ylab="value", main="states")
matplot(tD, M1D, type="b", lty=2, col=1:3, pch=4, add=TRUE)
legend("topright", legend = names(f), lty=1, col=1:3)
matplot(t, M2, type="l", lty=1, col=1:5, xlab="time", ylab="value", main="gradient")
source('~/cOde/inst/examples/example3.R')
?legend
source('~/cOde/inst/examples/example3.R')
source('~/cOde/inst/examples/example4.R')
f <- c(
O3 = " build_O3 * O2 * O - decay_O3 * O3",
O2 = "-build_O3 * O2 * O + decay_O3 * O3 + u",
O  = "-build_O3 * O2 * O + decay_O3 * O3"
)
# Compute sensitivity equations and get attributes
f_a <- adjointSymb(f)
chi <- attr(f_s, "chi")
grad <- attr(f_s, "grad")
forcings <- attr(f_s, "forcings")
func <- funC(f = f)
times <- seq(0, 15, by = .1)
yini <- c(O3 = 0, O2 = 2, O = 2.5)
pars <- c(build_O3 = .2, decay_O3 = .1, u = 0)
out <- odeC(y = yini,
times = times, func = func, parms = pars,
method = "lsodes")
out
class(out) <- "deSolve"
plot(out)
par(mfcol=c(1,2))
t <- out[,1]
M1 <- out[,2:4]
matplot(t, M1, type="l", lty=1, col=1:3, xlab="time", ylab="value", main="states")
pars <- c(build_O3 = .2, decay_O3 = .1, u = 0.1)
out <- odeC(y = yini,
times = times, func = func, parms = pars,
method = "lsodes")
t <- out[,1]
M1 <- out[,2:4]
matplot(t, M1, type="l", lty=1, col=1:3, xlab="time", ylab="value", main="states")
f_a <- adjointSymb(f, states = c("O3"), inputs = "u")
forcings <- attr(f_a, "forcings")
forcings
func <- funC(f = c(f, f_a), forcings = forcings)
f <- replaceSymbols("u", attr(f_a, "inputs"), f)
f
f_a <- adjointSymb(f, states = c("O3"), inputs = "u")
inputs <- attr(f_a, "inputs")
f_tot <- replaceSymbols("u", inputs, c(f, f_a))
forcings <- attr(f_a, "forcings")
func <- funC(f = f_tot, forcings = forcings)
names(f_tot)
forcings
f <- c(
O3 = " build_O3 * O2 * O - decay_O3 * O3 - u",
O2 = "-build_O3 * O2 * O + decay_O3 * O3",
O  = "-build_O3 * O2 * O + decay_O3 * O3"
)
library(bvpSolve)
inputs <- attr(f_a, "inputs")
f_tot <- replaceSymbols("u", inputs, c(f, f_a))
forcings <- attr(f_a, "forcings")
func <- funC(f = f_tot, forcings = forcings)
times <- seq(0, 15, by = .1)
boundary <- data.frame(
name = c("O3", "O2", "O", "adjO3", "adjO2", "adjO"),
yini = c(0.5, 2, 2.5, NA, NA, NA)
yend = c(NA, NA, NA, 0, 0, 0))
boundary <- data.frame(
name = c("O3", "O2", "O", "adjO3", "adjO2", "adjO"),
yini = c(0.5, 2, 2.5, NA, NA, NA),
yend = c(NA, NA, NA, 0, 0, 0))
pars <- c(build_O3 = .2, decay_O3 = .1, u = 0.1)
forcData <- data.frame(time = times,
name = rep(forcings, each=length(times)),
value = rep(c(0.5, 0, 1, 1), each=length(times)))
forc <- setForcings(func, forcData)
out <- bvptwpC(x = times, func = func, parms = pars, forcings = forc)
func <- funC(f = f_tot, forcings = forcings, jacobian = TRUE, boundary = boundary)
forc <- setForcings(func, forcData)
out <- bvptwpC(x = times, func = func, parms = pars, forcings = forc)
out
f <- c(
O3 = " build_O3 * O2 * O - decay_O3 * O3 - u",
O2 = "-build_O3 * O2 * O + decay_O3 * O3",
O  = "-build_O3 * O2 * O + decay_O3 * O3"
)
# Compute adjoints equations and replace u by optimal input
f_a <- adjointSymb(f, states = c("O3"), inputs = "u")
inputs <- attr(f_a, "inputs")
f_tot <- replaceSymbols("u", inputs, c(f, f_a))
forcings <- attr(f_a, "forcings")
# Initialize times, states, parameters
times <- seq(0, 15, by = .1)
boundary <- data.frame(
name = c("O3", "O2", "O", "adjO3", "adjO2", "adjO"),
yini = c(0.5, 2, 2.5, NA, NA, NA),
yend = c(NA, NA, NA, 0, 0, 0))
pars <- c(build_O3 = .2, decay_O3 = .1, eps = 1)
func <- funC(f = f_tot, forcings = forcings, jacobian = TRUE, boundary = boundary)
func
func <- funC(f = f_tot, forcings = forcings, jacobian = TRUE, boundary = boundary)
forcData <- data.frame(time = times,
name = rep(forcings, each=length(times)),
value = rep(c(0.5, 0, 1, 1), each=length(times)))
forc <- setForcings(func, forcData)
out <- bvptwpC(x = times, func = func, parms = pars, forcings = forc)
out
t <- out[,1]
M1 <- out[,2:4]
matplot(t, M1, type="l", lty=1, col=1:3, xlab="time", ylab="value", main="states")
inputs
as.list(out)
M2 <- with(c(as.list(pars), as.list(as.data.frame(out))),
eval(parse(text=inputs)))
inputs
colnames(out)
M2 <- with(list(uD = 0, adjO3 = out[,5], eps = 1, weightuD = 1),
eval(parse(text=inputs)))
M2
legend("topright", legend = names(f), lty=1, col=1:3)
matplot(t, M2, type="l", lty=1, col=1, xlab="time", ylab="value", main="input u")
source('~/cOde/inst/examples/example5.R')
inputs
source('~/cOde/inst/examples/example5.R')
times
dim(out)
length(times)
source('~/cOde/inst/examples/example5.R')
source('~/cOde/inst/examples/example5.R')
source('~/cOde/inst/examples/example5.R')
source('~/cOde/inst/examples/example5.R')
source('~/cOde/inst/examples/example3.R')
library(cOde)
?odeC
library(cOde)
?odeC
library(cOde)
?odeC
library(cOde)
?odeC
library(cOde)
?bvptwpC
?ode
library(cOde)
?funC
library(cOde)
?funC
# Exponential decay plus constant supply
f <- c(x = "-k*x + supply")
func <- funC(f, forcings = "supply")
library(cOde)
?setForcings
library(cOde)
rm(list=ls())
source('~/cOde/inst/examples/example4.R')
mynames
library(cOde)
source('~/cOde/inst/examples/example4.R')
x
y
f
replaceSymbols("O3", "1", f)
library(cOde)
debug(replaceSymbols)
checkCRAN(replaceSymbols)
library(cOde)
source('~/cOde/inst/examples/example4.R')
library(cOde)
source('~/cOde/inst/examples/example4.R')
library(cOde)
library(cOde)
library(cOde)
library(cOde)
library(cOde)
library(cOde)
library(cOde)
library(cOde)
library(cOde)
source('~/cOde/inst/examples/example4.R')
rm(lis)
library(cOde)
?odeC
library(cOde)
library(cOde)
data("oxygenData")
oxygenData
data("forcData")
forcData
data("diamonds")
library(ggplot2)
data("diamonds")
?diamonds
data(forcData)
data(forcData)
class(forcData)
install.packages("roxygen2")
library("roxygen2", lib.loc="~/R/x86_64-pc-linux-gnu-library/3.1")
forcData
library(cOde)
?forcData
library(cOde)
replaceOperation("^", "pow", "(x^2 + y^2)^(1/2)")
replaceOperation("^", "pow", "(x^2 + y^2)^.5")
jacobianSymb(c(x="A*B", y="A+B"), c("A", "B"))
jacobianSymb(c(A="A*B", B="A+B"))
library(inline)
?cfunction
sigSq <- signature(n="integer", x="numeric")
codeSq <- "
for (int i=0; i < *n; i++) {
x[i] = x[i]*x[i];
}"
sigQd <- signature(n="integer", x="numeric")
codeQd <- "
squarefn(n, x);
squarefn(n, x);
"
fns <- cfunction( list(squarefn=sigSq, quadfn=sigQd),
list(codeSq, codeQd),
convention=".C")
fns
fns[[1]]
str(fns[[1]])
getNativeSymbolInfo("squarefn")
library(bvpSolve)
library(deSolve)
library(cOde)
?adjointSymb
library(cOde)
?adjointSymb
library(cOde)
?adjointSymb
library(cOde)
library(cOde)
library(cOde)
?odeC
?adjointSymb
