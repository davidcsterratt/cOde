{
    "contents" : "\n#' Compute sensitivity equations of a function symbolically\n#' \n#' @param f named vector of type character, the functions\n#' @param states Character vector. Sensitivities are computed with respect to initial\n#' values of these states\n#' @param parameters Character vector. Sensitivities are computed with respect to initial\n#' values of these parameters\n#' @param inputs Character vector. Input functions or forcings. They are excluded from\n#' the computation of sensitivities.\n#' @details The sensitivity equations are ODEs that are derived from the original ODE f.\n#' They describe the sensitivity of the solution curve with respect to parameters like \n#' initial values and other parameters contained in f. These equtions are also useful\n#' for parameter estimation by the maximum-likelihood method. For consistency with the\n#' time-continuous setting provided by \\link{adjointSymb}, the returned equations contain\n#' attributes for the chisquare functional and its gradient.\n#' @return Named vector of type character with the sensitivity equations. Furthermore,\n#' attributes \"chi\" (the integrand of the chisquare functional), \"grad\" (the integrand\n#' of the gradient of the chisquare functional), \"forcings\" (Character vector of the \n#' additional forcings being necessare to compute \\code{chi} and \\code{grad}) and \"yini\" (\n#' The initial values of the sensitivity equations) are returned.\n#' @example inst/examples/example2.R\n#' @example inst/examples/example3.R\n#' @export\nsensitivitiesSymb <- function(f, states = names(f), parameters = NULL, inputs = NULL) {\n  \n  variables0 <- variables <- names(f)\n  parameters0 <- parameters\n  symbols <- getSymbols(f)\n  if(is.null(parameters)) parameters0 <- pars <- symbols[!symbols%in%c(variables, inputs)]\n    \n  \n  fun <- f\n  Dyf <- jacobianSymb(f)\n  Dpf <- jacobianSymb(f, pars)\n  \n  \n  f <- lapply(fun, function(felement) parse(text=felement))\n  \n  df <- length(f)\n  dv <- length(variables)\n  dp <- length(pars)\n  \n  # generate sensitivity variable names\n  mygridY0 <- expand.grid(variables, variables)\n  mygridP <- expand.grid(variables, pars)\n  sensParVariablesY0 <- apply(mygridY0, 1, paste, collapse=\".\")\n  sensParVariablesP <- apply(mygridP, 1, paste, collapse=\".\")\n  \n  # Write sensitivity equations in matrix form\n  Dy0y <- matrix(sensParVariablesY0, ncol=dv, nrow=dv)\n  Dpy <- matrix(sensParVariablesP, ncol=dp, nrow=dv)\n  gl <- c(as.vector(prodSymb(matrix(Dyf, ncol=dv), Dy0y)),\n          as.vector(sumSymb(prodSymb(matrix(Dyf,ncol=dv), Dpy), matrix(Dpf, nrow=dv))))\n  \n  \n  newfun <- gl\n  newvariables <- c(sensParVariablesY0, sensParVariablesP)\n  \n  names(newfun) <- newvariables\n  \n  # Append initial values\n  initials <- rep(0, length(newfun))\n  names(initials) <- newvariables\n  ones <- which(apply(mygridY0, 1, function(row) row[1] == row[2]))\n  initials[newvariables[ones]] <- 1\n  \n  # Compute wrss\n  if(is.null(parameters)) pars <- getSymbols(c(f, names(f)), exclude=inputs)\n  \n  statesD <- paste0(states, \"D\")\n  weightsD <- paste0(\"weight\", statesD)\n  \n  res <- paste0(weightsD,\"*(\", states, \"-\", statesD, \")\")\n  sqres <- paste0(res, \"^2\")\n  chi <- c(chi = paste0(sqres, collapse =\" + \"))\n    \n  sensitivities <- lapply(pars, function(p) paste0(states, \".\", p))\n  names(sensitivities) <- pars\n  \n  grad <- sapply(pars, function(p) paste0(paste(\"2*\", res, \"*\", sensitivities[[p]]), collapse=\" + \"))\n  names(grad) <- paste(\"chi\", pars, sep=\".\")\n  \n  attr(newfun, \"chi\") <- chi\n  attr(newfun, \"grad\") <- grad\n  attr(newfun, \"forcings\") <- c(statesD, weightsD)\n  attr(newfun, \"yini\") <- initials\n    \n  \n  return(newfun)\n  \n  \n}\n\n\n#' Compute adjoint equations of a function symbolically\n#' \n#' @param f Named vector of type character, the functions\n#' @param states Character vector of the ODE states for which observations are available\n#' @param inputs Character vector of the \"variable\" input states, i.e. time-dependent parameters\n#' (in contrast to the forcings).\n#' @param parameters Character vector of the parameters\n#' @details The adjoint equations are computed with respect to the functional \n#' \\deqn{(x, u)\\mapsto \\int_0^T \\|x(t)-x^D(t)\\|^2 + \\|u(t) - u^D(t)\\|^2 dt,}{(x, u) -> int( ||x(t) - xD(t)||^2 + ||u(t) - uD(t)||^2, dt),} \n#' where x are the states being constrained\n#' by the ODE, u are the inputs and xD and uD indicate the trajectories to be best\n#' possibly approached. When the ODE is linear with respect to u, the attribute \\code{inputs}\n#' of the returned equations can be used to replace all occurences of u by the corresponding\n#' character in the attribute. This guarantees that the input course is optimal with\n#' respect to the above function.\n#' @return Named vector of type character with the adjoint equations. The vector has attributes\n#' \"chi\" (integrand of the chisquare functional), \"grad\" (integrand of the gradient of the chisquare functional),\n#' \"forcings\" (character vector of the forcings necessary for integration of the adjoint equations) and\n#' \"inputs\" (the input expressed as a function of the adjoint variables).\n#' @example inst/examples/example5.R\n#' @export\nadjointSymb <- function(f, states=names(f), parameters = NULL, inputs=NULL) {\n  \n  n <- length(f)\n  \n  adjNames <- paste0(\"adj\", names(f))\n  \n  ## Compute adjoint sensitivities  \n  jac <- matrix(jacobianSymb(f), n)\n  \n  negadj <- as.vector(prodSymb(t(jac), matrix(adjNames, ncol=1)))\n  adj <- paste0(\"-(\", negadj, \")\")\n  names(adj) <- adjNames\n  \n  \n  negres <- paste0(\"(\", states, \"D - \", states, \")\") \n  wres <- paste(negres, paste0(\"weight\", states, \"D\"), sep=\"*\") \n  \n  \n  adj[paste0(\"adj\", states)] <- paste(adj[paste0(\"adj\", states)], wres, sep=\"+\")\n  \n  ## Input equations\n  u <- NULL\n  if(!is.null(inputs)) {\n    \n    jac <- matrix(jacobianSymb(f, inputs), n )\n    u <- as.vector(\n      sumSymb(paste0(inputs, \"D\"), \n              matrix(paste0(\"-(\",  \n                            as.vector(\n                              prodSymb(t(jac), matrix(adjNames, ncol=1))),\n                            \")*eps/weight\", inputs, \"D\"),\n                     ncol=1)\n      )\n    )\n    u <-  paste0(\"(\", u, \")\")\n    names(u) <- inputs\n    \n  }\n  \n  ## Forcings required by the BVP solver\n  forcings <- paste0(c(states, inputs), \"D\")\n  forcings <- c(forcings, paste0(\"weight\", forcings))\n  \n  \n  \n  ## Time-continous log-likelihood\n  res <- paste0(\"(\", c(states, inputs), \"-\", c(states, inputs), \"D)\")\n  sres <- paste0(res, \"^2\")\n  wsres <- paste(paste0(\"weight\", c(states, inputs), \"D\"),sres,  sep=\"*\") \n  \n  chi <- paste(wsres, collapse = \" + \")\n  names(chi) <- \"chi\"\n  attr(adj, \"chi\") <- chi\n  \n  ## Adjoint \"gradient wrt parameters\" equations\n  if(is.null(parameters)) {\n    symbols <- getSymbols(f)\n    parameters <- symbols[!(symbols%in%inputs) & !(symbols%in%names(f))]\n  }\n  if(length(parameters)>0) {\n    jac <- matrix(jacobianSymb(f, parameters), n)\n    grad <- as.vector(prodSymb(matrix(adjNames, nrow=1), jac))\n    gradP <- paste0(\"2*(\", grad, \")\")\n    names(gradP) <- paste(\"chi\", parameters, sep=\".\")\n    attr(adj, \"grad\") <- gradP  \n  }\n  \n  \n  \n  attr(adj, \"forcings\") <- forcings\n  attr(adj, \"inputs\") <- u\n  \n  \n  \n  \n  return(adj)\n  \n}\n\n\n#'@title Forcings data.frame\n#'@name forcData\n#'@docType data\n#' \nNULL\n\n#'@title Time-course data of O, O2 and O3\n#'@name oxygenData\n#'@docType data \nNULL\n",
    "created" : 1425847129518.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1689670744",
    "id" : "C66C328F",
    "lastKnownWriteTime" : 1425897035,
    "path" : "~/cOde/R/derivedEquations.R",
    "project_path" : "R/derivedEquations.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}